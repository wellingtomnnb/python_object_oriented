# -*- coding: utf-8 -*-
"""ObjectOrientation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/wellingtomnnb/9c78c929de6e2238d7312faef82509af/objectorientation.ipynb

### CONCEITOS DE POO
Programação orientada a objetos

#### Características Python

<li> Paradigma Imperativo / Procedural:
<ul><li> As instruções devem ser passadas ao computador na sequência em que devem ser executadas </ul>
<li> Paradigma Funcional:
<ul><li>Parte-se do princípio de que tudo são funções. Não existe uma lista de instruções ou objetos para o computador realizar, mas uma sequência de funções matemáticas que, juntas, vão resolver um problema. </ul>
    
<li> Paradigma Orientado a Objeto:
<ul><li>modelo de análise, projeto e programação baseado na aproximação entre o mundo real e o mundo virtual, através da criação e interação entre objetos, atributos, códigos, métodos, entre outros. <ul>

#### Pilares de POO

<li> <b>Abstração</b>
<p>Representação abstrata de um objeto real, que deve ser levado em conta a <b>identidade</b>, <b>propriedades</b> e os <b>métodos</b> desse objeto.
<ul><li>Coesão
<p> Para a abstração de um objeto a classe deve possuir atributos e métodos que correspondam exclusivamente as suas atribuições, tornando-a coesa.
    <p> Um exemplo de um objeto não coeso é um objeto do tipo <b>Pessoa</b> que tem um parâmetro chamado <b>`cor_roupa`</b>.

<li> <b>Encapsulamento</b>
<p> Elementos que adicionam <b>segurança</b> à aplicação em uma programação orientada a objetos pelo fato de <b>esconder as propriedades</b>, criando uma espécie de caixa preta.
<ul><li>Modificadores de Acesso
    <p>Determinam a <b>acessibilidade</b> e o <b>escopo</b> de vários elementos do nosso código, tais como: propriedades, métodos, construtores e classes.
<table border="1">
<tr>
  <th>Recupera dados:</th>
  <td>GET</td>
</tr>
<tr>
  <th>Palavra Reservada:</th>
  <td>@property</td>
</tr>
<tr>
  <th>Altera dados:</th>
  <td>SET</td>
</tr>
<tr>
  <th>Palavra Reservada:</th>
  <td>@{nome_função}.setter</td>
</tr>

</table>

<li><b>Herança</b>
<p>O objeto abaixo na hierarquia irá herdar características de todos os objetos acima dele, seus “ancestrais”.

<li><b>Polimorfismo</b>
<p> Alteração do funcionamento interno de um método herdado de um objeto pai.(Sobrecarga e Sobrescrita)

#### POO com Python

#####Classe Genérica (Abstrata)
"""

from abc import ABC, abstractmethod
# Criação de um Objeto Modelo
class Conta(ABC): 
    
  # Construtor do Objeto, que inicializa os atributos do objeto
  #`self`: Variável interna que registra o endereço do objeto em memória
  @abstractmethod
  def  __init__(self, num: int, nome: str, saldo: float = 0): 
      #`Undescore Duplo` (__) deixa a propriedade privada
      print(f"(Conta: {nome}): Construindo Objeto...")
      self.__numero = num
      self.__nome = nome
      self.__saldo = float(saldo)
      print(f"(Conta: {nome}): Objeto Construído.")
      
  #Encapsulamento
  def extrato(self): print(f'(Conta: {self.__nome}): Saldo: R${self.__saldo}')
  def deposito(self, valor): self.__saldo += valor
  def saque(self, valor): self.__saldo -= valor  
    
  #Abstração
  #Um método abstrato força a implementação do mesmo nas classes herdeiras
  @abstractmethod
  def transferencia(self, valor, destino): 
      self.saque(valor)
      destino.deposito(valor)
      print(self.__msg_transferencia(valor, destino))
    
  #Tipagem de Dados
  #Embora o Python trabalhe com a tipagem dinâmica, é possível informar
  #o tipo da variavel ou do retorno da função, para facilitar a compreensão
  def __msg_transferencia(self, valor:float, conta_dest, sucesso: bool = True) -> str:
      if sucesso: return (f'(Conta: {self.__nome}): \n._____________________________\n'+
          '|\n| * Transferência Concluída! *\n|\n'+
          f'| origem: {self.__nome}  | conta: {self.__numero}\n'+
          f'| destino: {conta_dest._Conta__nome} | conta: {conta_dest._Conta__numero}\n'+
          f'| valor: R${float(valor)}'+
          '\n|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n')
          
      else: return (f'(Conta: {self.__nome}):\n._____________________________\n'+
          '|\n| * Falha na Transferência! *\n|\n'+
          f'| origem: {self.__nome}  | conta: {self.__numero}\n'+
          f'| destino: {conta_dest._Conta__nome} | conta: {conta_dest._Conta__numero}\n'+
          f'| valor: R${float(valor)}'+
          '\n|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n')  
      
  #Interfaces
  #São contratos que forçam a implementação do mesmo nas classes herdeiras, uma vez que a função é chamada
  #Interfaces se não forem chamadas não dá erro, já os métodos abstratos sim
  def anuidade(self):
    raise NotImplementedError('O método `anuidade` precisa ser implementado na classe filho')
      
  #Modificadores de Acesso
  #`@property` indica que a função é uma propriedade do objeto, e não precisa de '()'
  @property
  def numero(self): return self.__numero
  @property
  def saldo(self): return self.__saldo
  @property
  def nome(self): return self.__nome
  #`@nome.setter` indica que a função é uma propriedade do objeto que altera o valor da variavel
  @nome.setter
  def nome(self, novo_nome): self.__nome = novo_nome

"""#####Classe Especializada (Herdeira)"""

#Herança
class ContaCorrente(Conta):
    
  #Polimorfismo
  # Overloading abstract method (Sobrecarga)
  def  __init__(self, num, nome, saldo = 0, taxa_porcent = 0.1):
      super().__init__(num, nome, saldo)
      self.__taxa = taxa_porcent
      
  
  #Overriding abstract method (Sobrescrita)
  def transferencia(self, valor, destino):
      taxa_valor =  valor * (self.__taxa/100)
      self.saque(valor + taxa_valor)
      destino.deposito(valor)
      print(self.__msg_transferencia(valor, destino, taxa_valor))
  
  def __msg_transferencia(self, valor, conta_dest: Conta, taxa_valor, sucesso = True):
      if sucesso: return (f'(Conta: {self.nome}): \n._____________________________\n'+
          '|\n| * Transferência Concluída! *\n|\n'+
          f'| origem: {self.nome}    | conta: {self.numero}\n'+
          f'| destino: {conta_dest.nome}   | conta: {conta_dest.numero}\n'+
          f'| valor: R${float(valor)}  | taxa: R${float(taxa_valor)}\n'+
          f'| total: R${float(valor+taxa_valor)}'+
          '\n|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n')
          
      else: return (f'(Conta: {self.nome}):\n._____________________________\n'+
          '|\n| * Falha na Transferência! *\n|\n'+
          f'| origem: {self.nome}    | conta: {self.numero}\n'+
          f'| destino: {conta_dest.nome}   | conta: {conta_dest.numero}\n'+
          f'| valor: R${float(valor)}  | taxa: R${float(taxa_valor)}\n'+
          f'| total: R${float(valor+taxa_valor)}'+
          '\n|,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n')

"""#####Manipulação do Objeto"""

# Instanciação do objeto
conta_well = ContaCorrente(100, 'Well',100, taxa_porcent = 1)
conta_x = ContaCorrente(101, 'Xiss',100)

# #Acessando métodos do objeto
conta_well.extrato(), conta_well.deposito(50), conta_well.extrato(), 
conta_well.saque(50), conta_well.extrato()
conta_well.transferencia(valor = 100, destino = conta_x)
conta_well.extrato(), conta_x.extrato()

# #Acessando atributos pelos métodos de acesso do objeto
conta_x.nome